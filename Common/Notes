
The light direction has to be relevant to the parent node
Right now


Lights should use the translation : float4x4(translation: skldjf) instead of just a flaot3.
Then i can treat them like model matrixs


// Scene graph - if the car lighting looks weird, its becuase we're moving the lights in GameScene.

// This calculates the flaot3 position of the nodeg
let nodePosition = node.worldTransform.columns.3.xyz

Got claires textures working except the mouth because it should be transparent.
The black parts should be baseColor.a == 0
Works when I check when r == 0, g == 0, b == 0 and then discard fragment
But that .a should come back as 0, so blender is exporting incorreclty or we're interrupting it incorrectly



Try importing a claire with animations and run one of the animations...


Claires textures are backwards compaired to mixamo


claire zup isn't actually right - blender is just rotated 90


IMPORTANT: need to pass along where the texture uv begins -> OBJ is bottom left?
This is in texturable
This is what made the lantern seem to break
Although the car did not?


***** If you get a blue screen thats half black and all fucked up ****
- Its probably because theres a nil texture somewhere in the shaders


When export gltf from blender / Make Human
- Need texture node
- Need images node - Update names
- Need to udpate materials to match the original shit "firstHuman_rigged_1_working_walk"
    - Update i
- If i export a new gltf file - Need to always add this shit


NEED TO DO CHARACTER SHADOWS



HEIGHT MAPS & COLLSION DETECTION (walking up and down hills)
https://developer.apple.com/documentation/metal/dynamic_terrain_with_argument_buffersg
https://www.youtube.com/watch?v=O9v6olrHPwI
https://www.youtube.com/watch?v=6E2zjfzMs7c


*** The issue must be with the heigh calculation before the shadow pass - because the shadow texture sample output looks
correct when I return the sample without multiplying it by the farz. Its just 6 points higher than it should be... its probably existing at y=0.


could be cool if we could do
shadowTransforms[0...5].position.y = pointer.pointee

and that would set the position of all transforms in that array slice
